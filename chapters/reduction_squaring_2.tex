\section{Introduction}

Arithmetic in the finite field $GF(2^m)$ of $2^m$ elements (also denoted $\F_{2^m}$) is fundamental for many important cryptosystems such as ECC (Elliptic Curve Cryptography). Such arithmetic is usually implemented by choosing an irreducible polynomial $f \in \F_2[x]$, $\deg(f) = m$, performing operations and reducing modulo this polynomial. It is common to have algorithms that implement arithmetic operations using a particular class of irreducible polynomials. This is because these algorithms are efficiently implemented considering such class of irreducibles.\\

Arithmetic operations in $GF(2^m)$ usually consist of addition (being equivalent to subtraction in characteristic 2), multiplication (of which squaring is a special case), and multiplicative inverses, used in divisions. All these operations are used in ECC, making any optimizations reflect directly on the speed of elliptic curve arithmetic, raising the importance of choosing an irreducible polynomial and associated algorithms. As examples, the classes of pentanomials $x^m+x^{n+2}+x^{n+1}+x^{n}+1$, $x^{4s}+x^{3s}+x^{2s}+x^s+1$, $x^m+x^{m-r}+x^s+x^r+1$ and $x^m+x^{n+1}+x^n+x+1$ are used in fast multipliers~\cite{fan2015survey}, each with their own fast multiplication and reduction algorithms.\\

However, the algorithms designed for irreducible polynomials with specific exponents may contain internal structures with an unclear impact on security of applications that use these algorithms. No attacks have been demonstrated so far, but the security community has seen evidence of standards containing back doors~\cite{bernstein2016dual} and cryptography failing due to fixed parameters~\cite{adrian2015imperfect}. In light of these events there has been discussions for less magic parameters and more randomness in the structures used.\\

A related problem is that many classes of irreducible polynomials contain few elements with degrees interesting for instance for ECC, often having no irreducible polynomials at all for a desired degree. Furthermore, choosing a class to speed up a specific operation may lead to less efficient algorithms for other operations used in the same application. Choosing the parameters for a field is therefore an exercise in tradeoffs. \\

In this chapter we introduce a general algorithm for $GF(2^m)$ modular reduction and an efficient squarer suitable for \emph{any} low-weight irreducible polynomial $f$. These algorithms operate on elements represented in polynomial basis, where the coefficients are stored simply as an array of bits, and operations are performed bitwise in a logic circuit. Such algorithms are usually measured by the number of bit-level XOR operations performed and their circuit delay (we note that only XOR operations are required in these algorithms). Previous works on this operation have been limited to certain classes of irreducible polynomials to achieve competitive efficiency, fixing the weight (number of non-zero elements) and the relationship among exponents. 
Although our algorithms hold for any low-weight polynomial, to achieve better circuit delay and be more comparable to other proposals, we focus on the pentanomial case $x^m+x^a+x^b+x^c+1$, $m > a > b > c > 0$, where $a \leq \ceil{m/2}$.\\

Our squarer has different costs depending on the irreducible polynomial used. Applications requiring utmost efficiency should choose an irreducible polynomial to minimize the global cost of operations. We observe there are polynomials that minimize the number of XOR operations and delay with our squarer; we show that low-weight polynomials with this characteristic are abundant (see Table~\ref{table:comparison_squarer} at Section~\ref{comparison}). Additionally, our squarer can be used for higher weight polynomials, with some performance penalty.\\

The structure of the next sections is as follows. In Section \ref{modrec}, we present a general algorithm to perform modular reduction. This algorithm is generic and can be used with any irreducible polynomial. In Section \ref{squaring}, we modify the algorithm previously proposed to make it a squarer. This strategy allowed us to propose a squarer algorithm of low complexity. In Section \ref{comparison}, we compare our squarer with previous methods for this operation. Section~\ref{pth} shows how the reduction and squaring algorithm can be generalized for $p$-th power computation in characteristic $p$. \\

\section{Modular reduction} \label{modrec}

Let $GF(2^m)$ be a finite field generated by an irreducible polynomial $f(x) = x^m + r(x)$, where $\deg(r) < m$. Some polynomial basis operations performed on this field may require a reduction modulo $f$. This is a classical operation; see for example \cite[Chapter~2.3.5]{hankerson2006guide}.\\

Let $C(x) = \sum_{i=0}^{d} c_i x^i$, $d \geq m$, be the result of an operation before the reduction mod $f$ is executed. A simple method for reduction consists of iteratively computing $C(x) \leftarrow C(x) + c_{i} x^{i-m} f(x)$ for $i = d, d-1, \ldots, m$, where each step $i$ reduces the coefficient $c_{i}$.\\

To reduce the number of operations we replace $c_{i} x^{i-m} f(x)$ with $c_{i} x^{i-m} r(x)$ in the equation above, and then compute the final result mod $x^m$, which is a simple truncation. This avoids one XOR per iteration because $r$ has one less coefficient than $f$. We consider the truncation to have negligible cost. Algorithm~\ref{alg:reduce} is a pseudocode representation of these operations. The input consists of $d+1$ signals (the input coefficients), which are modified using XOR operations and returned as $m$ signals. We describe the details of this algorithm since it is a step in the construction of the main contribution in this chapter: the squarer method given in the next section. \\

\begin{algorithm}
\caption{General modular reduction for $GF(2^m)$}
\label{alg:reduce}
\begin{algorithmic}[1]
\REQUIRE $C = [c_0, c_1, c_2, ..., c_d]$, $d \geq m$, $f(x) = x^m + r(x)$
\ENSURE $C \mod f$
\FOR{$i = d, d-1, \ldots, m$}
\FORALL{exponent $e$ \textbf{of} $r$}
\STATE $C[i-m+e] \leftarrow C[i-m+e] \oplus C[i]$ \label{alg:reduce:op}
\ENDFOR
\ENDFOR
\RETURN $C[0],~C[1],~C[2],~\ldots,~C[m-1]$
\end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:reduce} uses $(d-m+1)w_r$ XOR operations, where $w_h$ is the weight of the polynomial $h$. If $C$ is a product of two polynomials of degree at most $m-1$, then the degree of $C$ is at most $d \leq 2m-2$. It is common, in practical implementations, to fix $d=2m-2$. In this case, the number of XOR operations to perform a modular reduction for trinomials and pentanomials are $2m-2$ and $4m-4$, respectively. The trinomial algorithm can be trivially modified to the equally spaced case, $x^m+x^{m/2}+1$, for $m$ even, where many operations cancel themselves out and result in $1.5 m - 1$ XOR operations~\cite{wu2002bit}.\\

The delay of Algorithm~\ref{alg:reduce} depends on the exact polynomial used, ranging from $2 T_X$ to $(m-1) T_X$, where $T_X$ is the delay of a single XOR gate. Unfortunately, the delay has no clear pattern in our algorithm. For the pentanomial case with $a \leq \ceil{m/2}$, we have empirically observed the following relation in irreducible pentanomials of degree up to 800, $m$ prime (see Table~\ref{table:reduce:delays} for statistical breakdown):

\[
    \text{delay}(a, b, c)= 
\begin{cases}
    6 T_X, & \text{if } c > \ceil{a/2}; \\
    5 T_X, & \text{if } \ceil{a/2} \geq c > \min(\ceil{b/2}, a-b+1); \\
    4 T_X, & \text{otherwise.}
\end{cases}
\]

\begin{table}
\centering
\caption{Circuit delay of Algorithm~\ref{alg:reduce} for irreducible pentanomials $x^m + x^a + x^b + x^c + 1$, $m < 800$, $m$ prime, $a \leq \ceil{m/2}$.}
{\begin{tabular}{l l l} \label{table:reduce:delays}
Delay & \# pentanomials & Percentage \\ \hline
$4 T_X$ & $694,789$ & $34.53\%$ \\ \hline
$5 T_X$ & $826,066$ & $41.06\%$ \\ \hline 
$6 T_X$ & $491,096$ & $24.41\%$ \\ \hline
All & $2,011,941$ & $100\%$
\end{tabular}}{}
\end{table}

Higher values of delay are observed when $a > \ceil{m/2}$. This trend can also be seen in other algorithms~\cite{fan2015survey}, and it is likely a consequence of the number of reduction steps~\cite{wu2002bit}. This means that for low delay reduction of products it is preferable to have irreducible polynomials where the second highest exponent is less than half of the degree $m$.\\

For the rest of this chapter we focus on pentanomials with $d=2m-2$ and $a \leq \ceil{m/2}$.

% \textbf{Algoritmo de redução de trinômios equally spaced?}

% \textbf{Texto sobre delays está comentado.}
%The bit operations are parallelizable, with a critical path of length $$\left \lfloor \frac{d-m}{m-\deg(r)} \right \rfloor + 1 .$$ The circuit delay is then the critical path length times the delay of a single XOR gate, $T_X$.

%When $d=m$ or $d=m+1$ the delay is always $1 T_X$, regardless of $\deg(r)$. For values of $d$ between $m+2 \leq d \leq 2m-2$ a delay of $1 T_X$ is only possible when $d + \deg(r) < 2m$. A delay of $1 T_X$ is not possible for $d > 2m-2$.

%We note that the delay is $2T_X$ if $$2m-d~\leq~\deg(r)~<~\frac{3m-d}{2},$$ and therefore only possible when $m+2 \leq d < 3m-2$.

% This particular case has been treated in the literature; a delay of $1 T_X$ is only achievable for irreducible trinomials $x^m+x+1$, and a delay of $2 T_X$ happens for any irreducible polynomial where $\deg(r) \leq \ceil{m/2}$.

%In practice $d$ is taken to be $2m-2$, the size of a product between two polynomials of degree $m-1$.

% \textbf{Mostrar dedução das desigualdades em um ou dois passos. "We can have other $T_X$". Mencionar que $2 T_X$ só é possível . "Portanto, existem muitos valores de $d$, dado $m$, tal que o polinômio $r(x)$ existe e o delay é $\leq 2 T_X$". "The particular case $d=2m-2$ has been treated in the literature, and in this case $r(x)$ must be..."}

\section{Squaring} \label{squaring}

Given an element $A(x) = \sum_{i=0}^{m-1} a_i x^i$ in $GF(2^m)$, computing its square is usually cheaper than naively multiplying $A$ by itself~\cite{fan2015survey}. For instance, using normal basis, a squarer is just a shift, but this basis is avoided in many situations due to the higher cost of multiplications using this type of  basis~\cite{fan2015survey}.\\

Algorithm~\ref{alg:reduce} can be modified to perform fast squaring operations in polynomial basis by setting $d=2m-2$ and using the property that $A^2 = \sum_{i=0}^{m-1} a_i x^{2i}$. Therefore, $A^2$ can be computed by interspacing zeroes between the coefficients of $A$, followed by a modular reduction, if necessary~\cite{wu2002bit}. The new algorithm is shown in Algorithm~\ref{alg:square}. The placing of zeroes is considered to have negligible cost on a logical circuit, hence the complexity of our squarer is restricted by the complexity of performing the modular reduction of $A^2$.\\

In Algorithm~\ref{alg:reduce} the operation $C[i-m+e] \leftarrow C[i-m+e] \oplus C[i]$ on Step~\ref{alg:reduce:op} performs one XOR and modifies one coefficient. When applied to $A^2$, each operation falls into one of three cases, depending on the parity of the indexes, and if the coefficients have been modified by a previous operation. In the following we analyze these three cases. \\

\begin{description}
\item[Case 1:] $i$ is odd and $C[i]$ has not yet been modified, therefore $C[i]=0$, and the operation has no effect.
    
\begin{lem} \label{lemma:case1}
Let $\beta$ be the highest exponent of $r$ such that $\beta \not\equiv m \pmod {2}$. Case 1 above allows for $(m-1-\beta) / 2$ coefficients to be skipped.
\end{lem}

\begin{proof}
The bits of $C$ are modified at the index $i-m+e$. The highest possible odd index for $i-m+e$ is $m-2+\beta$, when $i=2m-2$ (first iteration) and $e = \beta$. Therefore all bits at odd indexes greater than or equal to $m+\beta$ are known to be zero and are never modified (Case 1). This skips $\left((2m-2) - (m+\beta) + 1\right)/2 = (m-1-\beta)/2$ iterations. Additionally, these bits are never used and can be omitted from the circuit.
\end{proof}

\item[Case 2:] $i-m+e$ is odd and $C[i-m+e]$ has not yet been modified, therefore $C[i-m+e]=0$, no XOR is required, and only the copy $C[i-m+e] \leftarrow C[i]$ is necessary.
    \begin{lem} \label{lemma:case2}
Case 2 above allows for $(m-1+\beta)/2$ XOR operations to be replaced with a simpler copy operation.
\end{lem}

\begin{proof}
The first time an odd coefficient is modified, the XOR and assignment operation can be replaced with a simple assignment since the previous value is known to be zero (Case 2). There are $m-1$ odd coefficients, of which $(m-1-\beta)/2$ are skipped per Lemma~\ref{lemma:case1}. The total number of XOR operations avoided in this case is then $(m-1+\beta)/2$.
\end{proof}

\item[Case 3:] Otherwise, the operation continues normally and XORs are performed.
\end{description}

\vspace{2mm}

Using the savings provided by Lemma~\ref{lemma:case1} and Lemma~\ref{lemma:case2} we can give the total cost of squaring using Algorithm~\ref{alg:reduce}.

\begin{thm} \label{theorem}
Polynomial basis squaring in $GF(2^m)$ can be computed in $(w_r-1) (m-1+\beta)/2$ XOR operations.
\end{thm}

\begin{proof}
    Algorithm~\ref{alg:reduce} can be used to perform a modular reduction of $A^2$ in $(m-1)w_r$ XOR operations. Lemma~\ref{lemma:case1} allows for $(m-1-\beta)/2$ coefficients to be skipped, saving $w_r$ XORs each. Furthermore Lemma~\ref{lemma:case2} avoids another $(m-1+\beta)/2$ XOR operations. Hence we can reduce the number of XOR operations by a total of $w_r (m-1-\beta)/2 + (m-1+\beta)/2$. The total number of operations is then $$(m-1)w_r - w_r (m-1-\beta)/2 + (m-1+\beta)/2 = (w_r-1) (m-1+\beta)/2.$$ The interspacing of zeroes, simple assignments and final truncation are considered to have negligible cost.
\end{proof}

Algorithm~\ref{alg:square} performs the zero interspacing and uses the above cases to reduce the number of operations during the reduction. The internal variable $S$ keeps track of which coefficients have been assigned and therefore which states are applicable. The algorithm ends with a truncation mod $x^m$ as in Algorithm~\ref{alg:reduce}. We note the case analysis depends only on the irreducible polynomial $f$ and can be precomputed, resulting in a list of simple assignments and XOR operations with fixed indexes. \\

By Theorem~\ref{theorem}, the total number of XOR operations performed in Algorithm~\ref{alg:square} is $(w_r-1) (m-1+\beta)/2$. This is equivalent to the state of the art for trinomials~\cite{wu2002bit}, but we observe our algorithm holds for irreducible polynomials of any weight. When using irreducible pentanomials the cost ranges from $1.5(m-1)$ when $\beta=0$ (all exponents odd except the independent term) to $3(m-1)$ when $\beta=m-1$. \\

For irreducible septanomials the cost of squaring is $2.5(m-1+\beta)$ XORs. This is interesting as a low $\beta$ septanomial can be more efficient than a high $\beta$ pentanomial. Unfortunately, there has been little research for septanomials and higher weights, therefore we focus on pentanomials for this chapter. \\

Having $\beta=0$ implies $m$, $a$, $b$ and $c$ are odd, and such irreducible pentanomials are plentiful. If the exponents of the pentanomial were randomly distributed, it is expected that about $12.5\%$ of the odd degree pentanomials would have $\beta=0$. We enumerate all irreducible binary pentanomials with $m < 800$, $m$ a prime number (a common assumption in ECC \cite{doche2005redundant}), $a \leq \ceil{m/2}$ (for low delay), and observe $2,011,941$ meet this restriction. \\

\begin{algorithm}
\caption{General squaring for $GF(2^m)$}
\label{alg:square}
\begin{algorithmic}[1]
\REQUIRE $A = [a_0, a_1, a_2, ..., a_{m-1}]$, $f(x) = x^m + r(x)$
\ENSURE $A^2 \mod f$

\STATE $C = [a_0, 0, a_1, 0, a_2, 0, \ldots, 0, a_{m-1}]$ \COMMENT{interspace zeroes}
\STATE $S = [0, 0, 0, \ldots, 0, 0]$, $|S| = |C|$

\FOR{$i = 2m-2, 2m-3, \ldots, m$}
    \IF{$i$ is odd \textbf{and} $S[i]=0$}
        \STATE{do nothing} \COMMENT{Case 1}
    \ELSE
        \FORALL{exponent $e$ \textbf{of} $r$}
            \IF{$i-m+e $ is odd \textbf{and} $S[i-m+e]=0$}
                \STATE{$C[i-m+e] \leftarrow C[i]$} \COMMENT{Case 2}
            \ELSE
                \STATE $C[i-m+e] \leftarrow C[i-m+e] \oplus C[i]$ \COMMENT{Case 3}
            \ENDIF
            \STATE $S[i-m+e] = 1$
        \ENDFOR
    \ENDIF
\ENDFOR

\RETURN $C[0],~C[1],~C[2],~\ldots,~C[m-1]$
\end{algorithmic}
\end{algorithm}

The squarer inherits the delay characteristics of the reduction algorithm and therefore must be evaluated on a per-case basis, but is always equivalent or better than the delay for a full reduction. Based on our observations we conjecture that the delay is between $3 T_X$ and $6 T_X$ for pentanomials when $a \leq \ceil{m/2}$ (see Table~\ref{table:square:delays}). \\

\begin{table}
\centering
\caption{Circuit delay of Algorithm~\ref{alg:square} for irreducible pentanomials $x^m + x^a + x^b + x^c + 1$, $m < 800$, $m$ prime, $a \leq \ceil{m/2}$.}
{\begin{tabular}{l l l} \label{table:square:delays}
Delay & \# pentanomials & Percentage \\ \hline
$3 T_X$ & $475,528$ & $23.63\%$ \\ \hline
$4 T_X$ & $1,076,788$ & $53.52\%$ \\ \hline
$5 T_X$ & $403,801$ & $20.07\%$ \\ \hline 
$6 T_X$ & $55,824$ & $2.78\%$ \\ \hline
All & $2,011,941$ & $100\%$
\end{tabular}}{}
\end{table}

\section{Comparison} \label{comparison}

There have been numerous works on the choice of irreducible polynomials for binary fields $GF(2^m)$ with the goal of optimizing bit-level arithmetic operations \cite{fan2015survey}. Trinomials and equally spaced polynomials are generally preferred but not available for every field size. \\

Table~\ref{table:comparison_squarer} compares the XOR count and delay of the best $GF(2^m)$ squarers in the literature that operate at the bit level and support polynomial basis. As noted, squarers from the literature require the irreducible polynomial $f$ to adhere to certain restrictions. For comparison we enumerate all pentanomials $f(x) = x^m + x^a + x^b + x^c + 1,~m < 800$, prime $m$, and we note how many of those adhered to each method's restrictions. This is a measure of the squarer's generality, as ideally a squarer should work on as many different irreducible polynomials as possible. \\

The current state of the art for polynomial basis squaring of a generic pentanomial is Park~\cite{park2012explicit}. The number of XOR gates is given by an upper bound of $(3m+7a-b-3c+25)/2$, and circuit delay at most $3T_X$. We note our squarer has an exact formula for the number of XOR gates, and it is strictly smaller than the upper bound mentioned. This can be seen by noting that $\beta \in \{a, b,c, 0\}$, thus our worst case is when $\beta = a$ resulting in $(3m+3a-3)/2$ XORs. Meanwhile, the best case for Park's upper bound happens when $b=a-1$ and $c=a-2$, resulting in $(3m+3a+32)/2$ XORs. We note that our worst case has a strictly smaller number of XOR operations than the current best upper bound. \\

\begin{table}
\centering
\caption{$GF(2^m)$ squarers for $x^m + x^a + x^b + x^c + 1$ in polynomial basis, $m > a > b > c > 0$, $m < 800$, $m$ prime, $\beta = \max{\{a, b, c, 0\}}$ such that $\beta \not \equiv m \pmod{2}$. Compare to results from Hariri \cite{hariri2009bit} and Park \cite{park2012explicit}}
{\begin{tabular}{l r l}
\label{table:comparison_squarer}
Proposal / Polynomials & \# irreducible & XOR count / Delay  \\ \hline
\specialcell{Hariri \\ $a=b+1=c+2$} & \specialcell{$602$} & \specialcell{$(m-3)/2 + m + 4$ \\ $2T_X$} \\ \hline
\specialcell{Park \\ $a \leq \ceil{m/2}$} & \specialcell{$2,011,941$}& \specialcell{$\leq (3m+7a-b-3c+25)/2$ \\ $3T_X$} \\ \hline
\specialcell{\emph{Ours, $\beta=0$, $3 T_X$ delay} \\ $a \leq \ceil{m/2}$} & \specialcell{$2,690$} & \specialcell{$1.5(m-1)$ \\ $3 T_X$} \\ \hline
\specialcell{\emph{Ours, any $\beta$, $3 T_X$ delay} \\ $a \leq \ceil{m/2}$} & \specialcell{$475,528$} & \specialcell{$1.5(m-1+\beta)$ \\ $3 T_X$} \\ \hline
\specialcell{\emph{Ours, $\beta=0$, any delay} \\ $a \leq \ceil{m/2}$} & \specialcell{$233,974$} & \specialcell{$1.5(m-1)$ \\ $3 T_X \leq k \leq 6 T_X$} \\ \hline
\specialcell{\emph{Ours, any $\beta$, any delay} \\ $a \leq \ceil{m/2}$} & \specialcell{$2,011,941$} & \specialcell{$1.5(m-1+\beta)$ \\ $3 T_X \leq k \leq 6 T_X$} \\ \hline
\specialcell{\emph{Ours, any $\beta$, any delay} \\ any $a<m$} & \specialcell{all} & \specialcell{ $1.5(m-1+\beta)$ \\ $3 T_X \leq k \leq (m-1) T_X$}
\end{tabular}}{}
\end{table}

Our squarer has variable delay depending on the irreducible pentanomial used, with values between $3 T_X$ to $6 T_X$ observed for $m < 800$, $m$ prime, $a \leq \ceil{m/2}$ (see Table~\ref{table:square:delays} for statistical distribution). Additionally, one can manually tweak the resulting circuit in order to reduce the total time delay, as shown in Appendix~\ref{appendix:example}. \\

Table~\ref{table:comparison_nist} compares the cost of using a naive reduction squaring (such as interspacing zeroes and applying Algorithm~\ref{alg:reduce}), with Park's squarer~\cite{park2012explicit} and our squarer (Algorithm~\ref{alg:square}) when applied to NIST ECC irreducible pentanomials. The squarer from Hariri~\cite{hariri2009bit} is not applicable in this case as NIST pentanomials are not of the format $x^m+x^{n+2}+x^{n+1}+x^{n}+1$. \\ 

\begin{table}
\centering
\smaller
\caption{Squarer cost for NIST suggested ECC irreducible pentanomials, in number of XOR operations and circuit delay, where "naive reduction" is Algorithm~\ref{alg:reduce}.}
{\begin{tabular}{l r r r} \label{table:comparison_nist}
Polynomial & Naive reduction & Park \cite{park2012explicit} & Our squarer \\ \hline
$x^{163} + x^7 + x^6 + x^3 + 1$ & $648\oplus/~5T_X$ & $246\oplus/~3T_X$ & $252\oplus/~4T_X$ \\ \hline
$x^{283} + x^{12} + x^7 + x^5 + 1$ & $1,118\oplus/~5T_X$ & $\leq468\oplus/~\leq3T_X$ & $441\oplus/~4T_X$ \\ \hline\
$x^{571} + x^{10} + x^5 + x^2 + 1$ & $2,280\oplus/~4T_X$ & $\leq898\oplus/~\leq3T_X$ & $870\oplus/~3T_X$
\end{tabular}}{}
\end{table}

\section{Generalized reduction and squaring in $GF(\MakeLowercase{p}^\MakeLowercase{m})$} \label{pth}

We recall that the reduction can be performed by iteratively computing $C(x) \leftarrow C(x) + c_{i} x^{i-m} f(x)$ for $i = d, d-1, \ldots, m$. This is sufficient to reduce polynomials in binary fields, but can be easily generalized to other finite field characteristics. \\

Let $C$ and $F$ be polynomials with coefficients in $\F_p$, $p$ a prime number, where $C = \sum_{i=0}^d c_i x^i$, and $F(x) = \sum_{i=0}^m f_i x^i$; we want to compute $C \mod F$. The $i$-th term of $C$ can be reduced by subtracting $c_i f_m^{-1} x^{i-m} F(x)$. Thus a full reduction can be performed by computing

$$C(x) \leftarrow C(x) - c_i f_m^{-1} x^{i-m} F(x).$$

There are two optimizations available. First, we note that after cancelling a power we do not use that array slot any more. Therefore we do not need to actually clear that coefficient but only truncate the result at the end. Second, the inverse $z = f_m^{-1}$ can be precomputed. The optimized algorithm is presented in Algorithm \ref{alg:general:reduce}. The total cost is $(d-m+1) (w_F-1)$ subtractions and twice as many multiplications, all in the characteristic of the finite field. \\

\begin{algorithm}
\caption{Optimized algorithm for calculating $C \mod F$}
\label{alg:general:reduce}
\begin{algorithmic}[1]
    \REQUIRE $C = [c_0, c_1, c_2, ..., c_d]$, $d \geq m$, $F(x) = f_m x^m + r(x)$, $z = f_m^{-1}$
    \ENSURE $C \mod F$
    \FOR{$i = d, d-1, \ldots, m$}
        \FORALL{exponent $e$ \textbf{of} $r$}
            \STATE $C[i-m+e] \leftarrow C[i-m+e] - C[i] \cdot z \cdot f_e \mod p$
        \ENDFOR
    \ENDFOR
    \RETURN $C[0],~C[1],~C[2],~\ldots,~C[m-1]$
\end{algorithmic}
\end{algorithm}

We note that in $\F_2$ subtractions are XORs; furthermore $z$ and $f_e$ are 1 and the multiplication can be removed, resulting in the $\F_2$ reduction Algorithm~\ref{alg:reduce}. Analogous to the squaring properties and case analysis presented in Section~\ref{squaring} we can use the general reduction performed by Algorithm~\ref{alg:general:reduce} to compute $p$-th powers. \\

The squaring property of $\F_2$ can be generalized to $A^p = \sum_{i=0}^{m-1} a_i x^{pi}$ for fields $\F_{p^m}$. Therefore to compute the $p$-th power of a polynomial in polynomial basis we can interspace $p-1$ zeros between them and perform a reduction. The case analysis of Section~\ref{squaring} can be rewritten to the $\F_{p^m}$ case as follows: \\

\begin{description}
\item[Case 1]: $i \not\equiv 0 \pmod{p}$ and $C[i]$ has not been modified, therefore $C[i] = 0$, and the operation has no effect;
\item[Case 2]: $i-m+e \not\equiv 0 \pmod{p}$ and $C[i-m+e]$ has not been modified, therefore $C[i-m+e] = 0$, the left side of the subtraction is $0$, and may be easily computed;
\item[Case 3]: otherwise, the operation continues normally and one subtraction and two multiplications are performed in the prime field $\F_p$.
\end{description}
    
The number of operations saved follows a similar pattern to our squarer but with more cancellations due to the extra zeroes inserted. It is not easy to derive a formula for the exact number of operations and resulting delay; if needed, both can be computed for specific cases by running the algorithm over the desired irreducible polynomial. \\