We recall that the reduction can be performed by iteratively computing $C(x) \leftarrow C(x) + c_{i} x^{i-m} f(x)$ for $i = d, d-1, \ldots, m$. This is sufficient to reduce polynomials in binary fields, but can be easily generalized to other finite field characteristics.

\begin{table}
\centering
\caption{Squarer cost for NIST suggested ECC irreducible pentanomials, in number of XOR operations and circuit delay, where "naive reduction" is Algorithm~\ref{alg:reduce}.}
{\begin{tabular}{l r r r} \label{table:comparison_nist}
Polynomial & Naive reduction & Park \cite{park2012explicit} & Our squarer \\ \hline
$x^{163} + x^7 + x^6 + x^3 + 1$ & $648\oplus/~5T_X$ & $246\oplus/~3T_X$ & $252\oplus/~4T_X$ \\ \hline
$x^{283} + x^{12} + x^7 + x^5 + 1$ & $1,118\oplus/~5T_X$ & $\leq468\oplus/~\leq3T_X$ & $441\oplus/~4T_X$ \\ \hline
$x^{571} + x^{10} + x^5 + x^2 + 1$ & $2,280\oplus/~4T_X$ & $\leq898\oplus/~\leq3T_X$ & $870\oplus/~3T_X$
\end{tabular}}{}
\end{table}

Let $C$ and $F$ be polynomials with coefficients in $\F_p$, $p$ a prime number, where $C = \sum_{i=0}^d c_i x^i$, and $F(x) = \sum_{i=0}^m f_i x^i$; we want to compute $C \mod F$. The $i$-th term of $C$ can be reduced by subtracting $c_i f_m^{-1} x^{i-m} F(x)$. Thus a full reduction can be performed by computing

$$C(x) \leftarrow C(x) - c_i f_m^{-1} x^{i-m} F(x).$$

There are two optimizations available. First, we note that after cancelling a power we do not use that array slot any more. Therefore we do not need to actually clear that coefficient but only truncate the result at the end. Second, the inverse $z = f_m^{-1}$ can be precomputed. The optimized algorithm is presented in Algorithm \ref{alg:general:reduce}. The total cost is $(d-m+1) (w_F-1)$ subtractions and twice as many multiplications, all in the characteristic of the finite field.

\begin{algorithm}
\caption{Optimized algorithm for calculating $C \mod F$}
\label{alg:general:reduce}
\begin{algorithmic}[1]
    \REQUIRE $C = [c_0, c_1, c_2, ..., c_d]$, $d \geq m$, $F(x) = f_m x^m + r(x)$, $z = f_m^{-1}$
    \ENSURE $C \mod F$
    \FOR{$i = d, d-1, \ldots, m$}
        \FORALL{exponent $e$ \textbf{of} $r$}
            \STATE $C[i-m+e] \leftarrow C[i-m+e] - C[i] \cdot z \cdot f_e \mod p$
        \ENDFOR
    \ENDFOR
    \RETURN $C[0],~C[1],~C[2],~\ldots,~C[m-1]$
\end{algorithmic}
\end{algorithm}

We note that in $\F_2$ subtractions are XORs; furthermore $z$ and $f_e$ are 1 and the multiplication can be removed, resulting in the $\F_2$ reduction Algorithm~\ref{alg:reduce}. Analogous to the squaring properties and case analysis presented in Section~\ref{squaring} we can use the general reduction performed by Algorithm~\ref{alg:general:reduce} to compute $p$-th powers.

The squaring property of $\F_2$ can be generalized to $A^p = \sum_{i=0}^{m-1} a_i x^{pi}$ for fields $\F_{p^m}$. Therefore to compute the $p$-th power of a polynomial in polynomial basis we can interspace $p-1$ zeros between them and perform a reduction. The case analysis of Section~\ref{squaring} can be rewritten to the $\F_{p^m}$ case as follows:

\begin{description}
\item[Case 1]: $i \not\equiv 0 \pmod{p}$ and $C[i]$ has not been modified, therefore $C[i] = 0$, and the operation has no effect;
\item[Case 2]: $i-m+e \not\equiv 0 \pmod{p}$ and $C[i-m+e]$ has not been modified, therefore $C[i-m+e] = 0$, the left side of the subtraction is $0$, and may be easily computed;
\item[Case 3]: otherwise, the operation continues normally and one subtraction and two multiplications are performed in the prime field $\F_p$.
\end{description}
    
The number of operations saved follows a similar pattern to our squarer but with more cancellations due to the extra zeroes inserted. It is not easy to derive a formula for the exact number of operations and resulting delay; if needed, both can be computed for specific cases by running the algorithm over the desired irreducible polynomial.