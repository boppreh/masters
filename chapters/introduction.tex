% Contextualizar: do geral oara o específico, do que se trata o teu trabalho - 5 a 10 parágrafos contextualizando
% Qual é o problema, por que o problema é um problema
% Objetivos Geral e específicos
% Motivação
% Justificativa
% Metodologia de pesquisa adotada
% Opcional: listar as principais contribuicoes
% Opcional: Limitaçoes do teu trabalho, no sentido do que nao é o teu trabalho

% Motivação: por que trabalhar nesse tema. "trabalho de cooperação itnernacional labsec com a universidade de carleton, onde foram feitos vários trabalhos na área de processamento rápido de corpos finitos". aspeco social, pessoal, laboratório, pesquisa. "durante os anos as pesquisam sendo realizadas no grupo de pesquisas do labsec, chegou-se a conclusao que o desempenho e performance de algoritmos não era o desejado, com a vinda e internacionalização do grupo de pesquisa especial, e cooperação com a unviersidade de Carleton, descobriu-se que haviam alguams coisas a fazer..."
% Justificativa: científiac. É importante melhorar o desempenho pra trabalhar na aritmética em corpos finitos? Algoritmos são as peças chaves, diminuir úmero de operacóes leva a melhor performance...

% Näo incluir áreas de pesquisa que não deram resultado: shamir, ECC, etc. Se tiver alguma coisa na mesma área, incluir nos trabalhos futuros
Finite field arithmetic is the fundamental for many important cryptosystems, such as ECC (Elliptic Curve Cryptography). Such arithmetic is often implemented by performing operations on integers or polynomials, then performing modular reduction on the result. The usage of binary polynomials is specially common for hardware implementations, as the operations map well to logic gates.

The performance of such system is important because it maps directly to fabrication costs, circuit area, power consumption, and execution time. Since finite field arithmetic is the basis of various cryptosystems, any optimizations in this area will cause improvements in the general system. Such improvements are specially useful for constrained systems, such as sensor networks.

This work has two general objectives. First, to act as an introduction to finite field arithmetic, and how fields based on binary polynomials are used in practice, down to the logic gates. It is our hope that this introduction can help future researchers that wish to understand or improve this area.

Our second general objective is to propose improvements on finite field arithmetic, with the goal of having these low level improvements leading to improvements in the overall system. Specifically, reducing the delay and number of logic gates required for reduction and squaring in binary finite fields; generalizing these improvements to other finite fields implemented with polynomials; and finally, translating these low level improvements to software algorithms.

Our work was motivated by the international cooperation between our Universidade Federal de Santa Catarina, and the Canadian Carleton University. This cooperation produced many projects related to fast processing in finite fields, specifically for cryptographic systems. This choice of subject was the result of a general dissatisfaction of the speed of the high level systems. The approach of optimizing the low level components was seen as a natural consequence of the expertise brought by this cooperation.

In Chapter~\label{cap:background} we introduce the basic mathematics behind finite field, with a goal of both introducing the subject for interested researchers, and to give the necessary background for the subsequent chapters. We focus on reduction and exponentiation of binary polynomials, and propose new hardware algorithms in Chapter~\ref{chapters/reduction_squaring_2}. In Chapter~\ref{chapters/word_processing} we contextualize and provide tools on how to translate hardware algorithms in a way to also be efficient in software. Chapter~\ref{chapters/visual_debugger} showscases the visualization tools we developed to help this research. Chapter~\ref{chapters/final_considerations} contains our final considerations, giving a conclusion and raising interesting future works.


\section{Binary finite field arithmetic in ECC} \label{background:binary}

% Mais para um capítulo de introdução do que de background.
% Faltando estado da arte, faltando tabela.
% Avanços históricos, em relação da complexidade.

Arithmetic in the finite field $GF(2^m)$ of $2^m$ elements (also denoted $\F_{2^m}$) is fundamental for many important cryptosystems such as ECC (Elliptic Curve Cryptography). Such arithmetic is usually implemented by choosing an irreducible polynomial $f \in \F_2[x]$, $\deg(f) = m$, performing operations and reducing modulo this polynomial. It is common to have algorithms that implement arithmetic operations using a particular class of irreducible polynomials. This is because these algorithms are efficiently implemented considering such class of irreducibles.\\

Arithmetic operations in $GF(2^m)$ usually consist of addition (being equivalent to subtraction in characteristic 2), multiplication (of which squaring is a special case) and inverses. All these operations are used in ECC, making any optimizations reflect directly on the speed of elliptic curve arithmetic, raising the importance of choosing an irreducible polynomial and associated algorithms. As examples, the classes of pentanomials $x^m+x^{n+2}+x^{n+1}+x^{n}+1$, $x^{4s}+x^{3s}+x^{2s}+x^s+1$, $x^m+x^{m-r}+x^s+x^r+1$ and $x^m+x^{n+1}+x^n+x+1$ are used in fast multipliers~\cite{fan2015survey}, each with their own fast multiplication and reduction algorithms.\\

However, the algorithms designed for irreducible polynomials with specific exponents may contain internal structures with an unclear impact on security of applications that use these algorithms. No attacks have been demonstrated so far, but the security community has seen evidence of standards containing back doors~\cite{bernstein2016dual} and cryptography failing due to fixed parameters~\cite{adrian2015imperfect}. In light of these events there has been discussions for less magic parameters and more randomness in the structures used.\\

A related problem is that many classes of irreducible polynomials contain few elements with degrees interesting for instance for ECC, often having no irreducible polynomials at all for a desired degree. Furthermore, choosing a class to speed up a specific operation may lead to less efficient algorithms for other operations used in the same application. Choosing the parameters for a field is therefore an exercise in tradeoffs.

%\section{Objectives}
%
%General objectives:
%
%\begin{itemize}
%	\item Get introduced to finite field arithmetic.
%	\item Speed up cryptographic systems that depend on finite field arithmetic.
%\end{itemize}
%
%Specific objectives:
%
%\begin{itemize}
%	\item Create an efficient, general algorithm for binary polynomial reduction.
%	\item Create an efficient, general algorithm for binary polynomial squaring.
%	\item Translate speedups from hardware-oriented algorithms to software.
%\end{itemize}